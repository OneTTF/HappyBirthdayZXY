<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script>
      (function(){
        try {
          var ua = navigator.userAgent || "";
          var looksMobile = /Android|iPhone|iPad|iPod|Windows Phone|Mobile|Mobi/i.test(ua) || Math.min(screen.width, screen.height) < 769 || window.innerWidth < 769;
          if (looksMobile) {
            window.location.replace('mobile.html' + window.location.search + window.location.hash);
          }
        } catch(e) { /* ignore */ }
      })();
    </script>
    <style>
        body {
            margin: 0;
            padding: clamp(12px, 4vw, 32px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #ffffff;
            overflow-x: hidden;
            overflow-y: auto;
        }
        canvas {
            display: block;
            max-width: min(92vw, 900px);
            width: min(92vw, 900px);
            height: auto;
        }
        @media (max-width: 768px) {
            body {
                align-items: flex-start;
                padding-bottom: 48px;
            }
            canvas {
                box-shadow: 0 3px 8px rgba(0, 0, 0, 0.12);
                border-radius: 12px;
            }
        }
        #rain-container {
            position: fixed;
            inset: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            pointer-events: none;
            z-index: 10;
        }
        .cake {
            position: absolute;
            top: -10%;
            will-change: transform;
            animation: fall var(--duration, 10s) linear var(--delay, 0s) infinite;
            opacity: 0.9;
            filter: drop-shadow(0 2px 2px rgba(0,0,0,0.15));
        }
        @keyframes fall {
            0% { transform: translate3d(0, -120%, 0); }
            100% { transform: translate3d(0, 120vh, 0); }
        }
        #musicBtn {
            position: fixed;
            top: 14px;
            right: 14px;
            z-index: 20;
            width: 42px;
            height: 42px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            border: 2px solid #111;
            border-radius: 50%;
            background: transparent;
            color: #111;
            font-size: 18px;
            line-height: 1;
            cursor: pointer;
            box-shadow: none;
            transition: background 0.2s, color 0.2s;
        }
        #musicBtn:hover { background: #111; color: #fff; }
        #intro {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #fff5f7, #f0f9ff);
            z-index: 30;
        }
        #intro .box {
            text-align: center;
            padding: 0;
            background: transparent;
            box-shadow: none;
            transform: translateY(-8vh);
        }
        #intro h1 { display: none; }
        #intro p { margin: 0 0 18px; color: #222; font-size: clamp(14px, 2.2vw, 16px); letter-spacing: 1px; }
        #startBtn {
            padding: 10px 18px;
            border: 1.5px solid #2e7d32;
            border-radius: 10px;
            background: #fff;
            color: #2e7d32;
            font-size: clamp(14px, 2vw, 15px);
            cursor: pointer;
            transition: background 0.2s, color 0.2s;
        }
        #startBtn:hover { background: #eaf6ed; }
        @media (max-width: 768px) {
            #musicBtn { width: 38px; height: 38px; font-size: 16px; top: 12px; right: 12px; }
        }
    </style>
</head>
<body>
    <div id="intro" role="dialog" aria-modal="true">
        <div class="box">
            <p>æ¸©é¦¨æé†’ï¼šä½©æˆ´è€³æœºå¹¶æé«˜éŸ³é‡å¯è·å¾—æœ€ä½³ä½“éªŒå“¦ ğŸ˜Š</p>
            <button id="startBtn" type="button">å‡†å¤‡å¥½äº†ï¼Œæˆ‘ä»¬å¼€å§‹å§ï¼</button>
        </div>
    </div>
    <canvas id="canvas" width="1000" height="800"></canvas>
    <div id="rain-container" aria-hidden="true"></div>
    <audio id="bgm" src="music.mp3" preload="auto" loop></audio>
    <button id="musicBtn" type="button">â–¶</button>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const BASE = { w: 1000, h: 800 };
        function setupCanvas() {
            const dpr = Math.max(1, window.devicePixelRatio || 1);
            const displayWidth = Math.round(canvas.clientWidth);
            const displayHeight = Math.round(canvas.clientHeight || (displayWidth * BASE.h / BASE.w));
            canvas.width = Math.max(1, Math.floor(displayWidth * dpr));
            canvas.height = Math.max(1, Math.floor(displayHeight * dpr));
            applyTransform();
        }

        function applyTransform() {
            const cw = canvas.width;
            const ch = canvas.height;
            const base = Math.min(cw / BASE.w, ch / BASE.h);
            const scale = base * cakeScale();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.translate(cw / 2, ch / 2 - offsetPx());
            ctx.scale(scale, -scale);
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
        }
        ctx.lineJoin = 'round';
        ctx.lineCap = 'round';

        const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
        const fast = (ms) => Math.max(16, ms * (CONFIG.timing.speedFactor));

        const CONFIG = {
            // ç¥ç¦æ–‡æ¡ˆï¼šæ˜¾ç¤ºåœ¨è›‹ç³•ä¸Šæ–¹çš„æ–‡æœ¬
            greetingText: 'å¼ æ¬£æ€¡ Happy Birthday',

            // è›‹ç³•é›¨å‚æ•°
            cakeRain: {
                // ä¸‹è½çš„è¡¨æƒ…/å›¾æ ‡é›†åˆï¼ˆä¼šéšæœºé€‰æ‹©ï¼‰
                icons: ['ğŸ°', 'ğŸ‚'],
                // ç”Ÿæˆé—´éš”ï¼ˆæ¯«ç§’ï¼Œè¶Šå°è¶Šå¯†é›†ï¼‰
                intervalMs: 300,
                // åˆå§‹å–·å‘æ•°é‡ï¼ˆè¿›å…¥æ—¶å¿«é€Ÿå¡«å……å±å¹•ï¼‰
                initialBurst: 20,
                // å›¾æ ‡æœ€å°/æœ€å¤§å­—å·ï¼ˆåƒç´ ï¼‰
                sizeMin: 13,
                sizeMax: 36,
                // ä¸‹è½æ€»æ—¶é•¿ä¸Šä¸‹é™ï¼ˆç§’ï¼Œè¶Šå°è¶Šå¿«ï¼‰
                durationMin: 6,
                durationMax: 12
            },

            // æ ·å¼ä¸å¸ƒå±€ï¼ˆæŒ‰è®¾å¤‡è‡ªé€‚é…ï¼‰
            style: {
                // æ¡Œé¢ç«¯æ•´ä½“ç¼©æ”¾æ¯”ä¾‹ï¼ˆ>1 æ”¾å¤§ï¼‰
                scaleDesktop: 1.2,
                // ç§»åŠ¨ç«¯æ•´ä½“ç¼©æ”¾æ¯”ä¾‹ï¼ˆ>1 æ”¾å¤§ï¼‰
                scaleMobile: 1.25,
                // æ¡Œé¢ç«¯ä¸‹ç§»é‡ï¼ˆåƒç´ ï¼Œæ­£å€¼å¾€ä¸‹ï¼‰
                offsetDesktopPx: 60,
                // ç§»åŠ¨ç«¯ä¸‹ç§»é‡ï¼ˆåƒç´ ï¼Œæ­£å€¼å¾€ä¸‹ï¼‰
                offsetMobilePx: 40,
                // æ¡Œé¢ç«¯æ˜¯å¦ç»˜åˆ¶æè¾¹ï¼ˆfalse æ›´å¹²å‡€ï¼‰
                showStrokeDesktop: false,
                // ç§»åŠ¨ç«¯æ˜¯å¦ç»˜åˆ¶æè¾¹ï¼ˆå°å±ç»†æè¾¹å¯æå‡æ¸…æ™°åº¦ï¼‰
                showStrokeMobile: false
            },

            // ç»˜åˆ¶ä¸åŠ¨æ•ˆèŠ‚å¥
            timing: {
                // é€Ÿåº¦ç³»æ•°ï¼šfast(ms) = max(16, ms * speedFactor)ï¼Œå€¼è¶Šå¤§åŠ¨ç”»è¶Šæ…¢
                speedFactor: 4.0
            }
        };
        function isMobile(){ return (window.innerWidth||0) < 769; }
        function cakeScale(){ return isMobile()? CONFIG.style.scaleMobile : CONFIG.style.scaleDesktop; }
        function offsetPx(){ return isMobile()? CONFIG.style.offsetMobilePx : CONFIG.style.offsetDesktopPx; }
        function strokesEnabled(){ return isMobile()? CONFIG.style.showStrokeMobile : CONFIG.style.showStrokeDesktop; }
        let playBgm;

        function radians(degrees){ return (degrees * Math.PI) / 180; }
        function rgbColor(r,g,b,a=1){ return `rgba(${Math.round(r*255)}, ${Math.round(g*255)}, ${Math.round(b*255)}, ${a})`; }
        function drawX(a,i){ const t=radians(i); return a*Math.cos(t); }
        function drawY(b,i){ const t=radians(i); return b*Math.sin(t); }

        function generateEllipsePoints(i1,i2,a,b,xOffset,yOffset,nums1=1,nums2=1,stepSize=5){
            const points=[]; if(stepSize===0){ return points; }
            const forward=i2>=i1; const step=forward? Math.abs(stepSize) : -Math.abs(stepSize);
            let angle=i1;
            while((forward && angle<=i2) || (!forward && angle>=i2)){
                const x=drawX(a, angle*nums1)+xOffset; const y=drawY(b, angle*nums2)+yOffset; points.push({x,y});
                if(angle===i2){ break; }
                angle+=step; if((forward && angle>i2) || (!forward && angle<i2)){ angle=i2; }
            }
            return points;
        }

        function mergePoints(...groups){
            const merged=[]; for(const group of groups){ if(!group) continue; for(const point of group){ if(!merged.length){ merged.push(point); continue; } const last=merged[merged.length-1]; if(last.x!==point.x || last.y!==point.y){ merged.push(point); } } } return merged;
        }

        async function animateStroke(points,{color,width=1,duration=600}){
            if(!points || points.length<2){ return; }
            if(!strokesEnabled()){ return; }
            const segments=points.length-1; const scaledDuration=Math.max(60, duration*(CONFIG.timing.speedFactor)); const stepDuration=scaledDuration/segments;
            ctx.save(); ctx.strokeStyle=color; ctx.lineWidth=width; ctx.lineCap='round';
            for(let i=0;i<segments;i++){ const from=points[i]; const to=points[i+1]; ctx.beginPath(); ctx.moveTo(from.x,from.y); ctx.lineTo(to.x,to.y); ctx.stroke(); await sleep(stepDuration); }
            ctx.restore();
        }

        function fillShape(points,color){ if(!points||!points.length){ return; } ctx.save(); ctx.beginPath(); ctx.moveTo(points[0].x,points[0].y); for(let i=1;i<points.length;i++){ ctx.lineTo(points[i].x,points[i].y);} ctx.closePath(); ctx.fillStyle=color; ctx.fill(); ctx.restore(); }

        function clearCanvas(){ ctx.save(); ctx.setTransform(1,0,0,1,0,0); ctx.clearRect(0,0,canvas.width,canvas.height); ctx.restore(); applyTransform(); }
        function drawBackground(){ }

        function setupAudio(){ const audio=document.getElementById('bgm'); const btn=document.getElementById('musicBtn'); const update=()=>{ btn.textContent = audio.paused? 'â–¶':'â¸'; }; btn.addEventListener('click',()=>{ if(audio.paused){ audio.play(); } else { audio.pause(); } update(); }); audio.addEventListener('play',update); audio.addEventListener('pause',update); update(); playBgm = ()=>{ audio.play().finally(update); }; }

        function startCakeRain(cfg=CONFIG.cakeRain){ const container=document.getElementById('rain-container'); const cakes=Array.isArray(cfg.icons)&&cfg.icons.length? cfg.icons:['ğŸ°','ğŸ‚']; function spawn(){ const el=document.createElement('span'); el.className='cake'; el.textContent=cakes[Math.floor(Math.random()*cakes.length)]; const size=Math.random()*(cfg.sizeMax-cfg.sizeMin)+cfg.sizeMin; el.style.left=Math.random()*100+'vw'; el.style.fontSize=size+'px'; const duration=Math.random()*(cfg.durationMax-cfg.durationMin)+cfg.durationMin; el.style.setProperty('--duration', duration.toFixed(2)+'s'); el.style.setProperty('--delay', (Math.random()*2).toFixed(2)+'s'); container.appendChild(el); setTimeout(()=>el.remove(), (cfg.durationMax+4)*1000); } setInterval(spawn, Math.max(60, cfg.intervalMs)); for(let i=0;i<(cfg.initialBurst||0);i++) setTimeout(spawn, i*120); }

        function initIntro(){ const intro=document.getElementById('intro'); const startBtn=document.getElementById('startBtn'); if(!startBtn) return; startBtn.addEventListener('click', ()=>{ intro.style.display='none'; if(typeof playBgm==='function') playBgm(); startCakeRain(); drawScene(); }); }

        async function drawGreeting(yPosition=200){ ctx.save(); ctx.scale(1,-1); ctx.font='bold 70px "Curlz MT", cursive'; ctx.textAlign='center'; ctx.textBaseline='bottom'; ctx.fillStyle=rgbColor(241/255,173/255,209/255); const targetY=-yPosition; for(let alpha=0; alpha<=1.001; alpha+=0.1){ ctx.globalAlpha=alpha; ctx.fillText(CONFIG.greetingText,0,targetY); await sleep(fast(60)); } ctx.restore(); ctx.globalAlpha=1; }

        async function drawScene(){ clearCanvas(); applyTransform(); drawBackground(); const baseTopColor=rgbColor(254/255,245/255,247/255); const baseTopPoints=generateEllipsePoints(0,360,150,60,0,-70); const baseBottomColor=rgbColor(246/255,226/255,230/255); const baseBottomPoints=mergePoints([{x:150,y:-70}], generateEllipsePoints(0,180,150,60,0,-70,-1,-1), generateEllipsePoints(180,360,150,70,0,-70)); const timeline=[]; timeline.push(async()=>{ await animateStroke(baseTopPoints,{color:baseTopColor,width:2,duration:700}); }); timeline.push(async()=>{ fillShape(baseTopPoints,baseTopColor); await sleep(fast(150)); }); timeline.push(async()=>{ await animateStroke(baseBottomPoints,{color:baseBottomColor,width:2,duration:700}); }); timeline.push(async()=>{ fillShape(baseBottomPoints,baseBottomColor); await sleep(fast(150)); }); const cakeColor1=rgbColor(203/255,217/255,249/255); const bottomColor=rgbColor(255/255,167/255,157/255); const curveColor1=rgbColor(255/255,240/255,243/255); const topColor1='white'; const lowerMainPoints=mergePoints([{x:120,y:-70},{x:120,y:0}], generateEllipsePoints(0,180,120,48,0,0), [{x:-120,y:-70}], generateEllipsePoints(180,360,120,48,0,-70)); const lowerMirrorPoints=mergePoints(generateEllipsePoints(0,180,120,48,0,-70,-1,-1), generateEllipsePoints(180,360,120,48,0,-60)); const lowerBorderPoints=mergePoints([{x:120,y:0}], generateEllipsePoints(0,1799,120,-18,0,-60,0.1,1,5), [{x:-120,y:0}], generateEllipsePoints(180,0,120,48,0,0)); const lowerTopPoints=mergePoints([{x:110,y:0}], generateEllipsePoints(0,360,110,40,0,2)); timeline.push(async()=>{ await animateStroke(lowerMainPoints,{color:cakeColor1,width:2,duration:900}); }); timeline.push(async()=>{ fillShape(lowerMainPoints,cakeColor1); await sleep(fast(150)); }); timeline.push(async()=>{ await animateStroke(lowerMirrorPoints,{color:bottomColor,width:2,duration:600}); }); timeline.push(async()=>{ fillShape(lowerMirrorPoints,bottomColor); await sleep(fast(120)); }); timeline.push(async()=>{ await animateStroke(lowerBorderPoints,{color:curveColor1,width:2,duration:900}); }); timeline.push(async()=>{ fillShape(lowerBorderPoints,curveColor1); await sleep(fast(120)); }); timeline.push(async()=>{ await animateStroke(lowerTopPoints,{color:topColor1,width:2,duration:600}); }); timeline.push(async()=>{ fillShape(lowerTopPoints,topColor1); await sleep(fast(120)); }); const cakeColor2=rgbColor(111/255,55/255,50/255); const curveColor2=rgbColor(255/255,170/255,160/255); const topColor2=rgbColor(255/255,195/255,190/255); const upperMainPoints=mergePoints([{x:80,y:4},{x:80,y:54}], generateEllipsePoints(0,180,80,32,0,54), [{x:-80,y:4}], generateEllipsePoints(180,360,80,32,0,4)); const upperBorderPoints=mergePoints([{x:80,y:54}], generateEllipsePoints(0,1799,80,-12,0,14,0.1,1,5), [{x:-80,y:54}], generateEllipsePoints(180,0,80,32,0,54)); const upperTopPoints=mergePoints([{x:70,y:54}], generateEllipsePoints(0,360,70,28,0,55)); timeline.push(async()=>{ await animateStroke(upperMainPoints,{color:cakeColor2,width:2,duration:800}); }); timeline.push(async()=>{ fillShape(upperMainPoints,cakeColor2); await sleep(fast(120)); }); timeline.push(async()=>{ await animateStroke(upperBorderPoints,{color:curveColor2,width:2,duration:700}); }); timeline.push(async()=>{ fillShape(upperBorderPoints,curveColor2); await sleep(fast(120)); }); timeline.push(async()=>{ await animateStroke(upperTopPoints,{color:topColor2,width:2,duration:600}); }); timeline.push(async()=>{ fillShape(upperTopPoints,topColor2); await sleep(fast(120)); }); const candles=[{x1:-56,y1:54,x2:-64,y2:104},{x1:-26,y1:44,x2:-34,y2:94},{x1:4,y1:64,x2:-4,y2:114},{x1:34,y1:44,x2:26,y2:94},{x1:64,y1:54,x2:56,y2:104}]; const candleColor=rgbColor(177/255,201/255,233/255); const flameColor=rgbColor(241/255,173/255,209/255); const cakeBodyTopY=Math.max(...upperTopPoints.map((p)=>p.y)); const cakeBodyBottomY=Math.min(...lowerMainPoints.map((p)=>p.y)); const highestFlameY=Math.max(...candles.map((c)=>c.y2+30)); const highestStructureY=Math.max(cakeBodyTopY,highestFlameY); const greetingY=highestStructureY+60; for(const candle of candles){ const bodyPoints=mergePoints([{x:candle.x1,y:candle.y1},{x:candle.x1,y:candle.y2}], generateEllipsePoints(0,180,4,2,candle.x1-4,candle.y2), [{x:candle.x2,y:candle.y1}], generateEllipsePoints(180,360,4,2,candle.x2+4,candle.y1)); const stripes=Array.from({length:5},(_,index)=>{ const offset=index+1; return [{x:candle.x2,y:candle.y1+10*offset},{x:candle.x1,y:candle.y1+10*offset}]; }); const connector=[{x:candle.x1-4,y:candle.y2},{x:candle.x1-4,y:candle.y2+10}]; const flamePoints=generateEllipsePoints(0,360,4,10,candle.x1-4,candle.y2+20); timeline.push(async()=>{ await animateStroke(bodyPoints,{color:candleColor,width:2,duration:500}); }); timeline.push(async()=>{ fillShape(bodyPoints,candleColor); await sleep(fast(80)); }); timeline.push(async()=>{ ctx.save(); ctx.strokeStyle='white'; ctx.lineWidth=2; for(const stripe of stripes){ ctx.beginPath(); ctx.moveTo(stripe[0].x,stripe[0].y); ctx.lineTo(stripe[1].x,stripe[1].y); ctx.stroke(); await sleep(fast(80)); } ctx.restore(); }); timeline.push(async()=>{ await animateStroke(connector,{color:'white',width:2,duration:200}); }); timeline.push(async()=>{ await animateStroke(flamePoints,{color:flameColor,width:2,duration:400}); }); timeline.push(async()=>{ fillShape(flamePoints,flameColor); await sleep(fast(80)); }); }
            for(const step of timeline){ await step(); }
            await sleep(fast(200));
            await drawGreeting(greetingY);
        }

        setupCanvas();
        window.addEventListener('resize', setupCanvas);
        setupAudio();
        initIntro();
    </script>
</body>
</html>
